<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>摄像头特征点检测与3D空间还原</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .camera-section, .point-cloud-section {
            flex: 1;
            min-width: 300px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
        }
        .video-container {
            position: relative;
            width: 100%;
            margin-bottom: 15px;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
            min-height: 300px; /* 防止加载时高度塌陷 */
        }
        .camera-loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        #video {
            width: 100%;
            display: block;
            background: #000;
            transform: scaleX(-1); /* 镜像翻转，操作更自然 */
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #pointCloud {
            width: 100%;
            height: 300px;
            background: #1a1a2e;
            border-radius: 10px;
            display: block;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        #cameraSelect {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #f8f9fa;
            color: #333;
            font-weight: bold;
            min-width: 120px;
            cursor: pointer;
        }
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #3498db;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #stop {
            background: #e74c3c;
        }
        #stop:hover {
            background: #c0392b;
        }
        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            font-size: 0.9rem;
            flex-wrap: wrap;
            gap: 10px;
        }
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
        }
        .instructions {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .instructions h2 {
            margin-bottom: 15px;
            text-align: center;
        }
        .instructions ul {
            list-style-type: none;
        }
        .instructions li {
            margin-bottom: 10px;
            padding-left: 20px;
            position: relative;
        }
        .instructions li:before {
            content: "•";
            color: #fdbb2d;
            font-weight: bold;
            position: absolute;
            left: 0;
        }
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            h1 {
                font-size: 1.8rem;
            }
            button, #cameraSelect {
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>摄像头特征点检测与3D空间还原</h1>
            <p class="subtitle">实时检测特征点并还原为3D点云</p>
        </header>
        
        <div class="content">
            <div class="camera-section">
                <h2 class="section-title">摄像头视图</h2>
                <div class="video-container">
                    <div class="camera-loading" id="cameraLoading">请选择摄像头并点击开始检测</div>
                    <video id="video" autoplay playsinline style="display: none;"></video>
                    <canvas id="canvas" style="display: none;"></canvas>
                </div>
                <div class="controls">
                    <select id="cameraSelect" disabled>
                        <option value="">加载中...</option>
                    </select>
                    <button id="start">开始检测</button>
                    <button id="stop" disabled>停止检测</button>
                </div>
                <div class="stats">
                    <div class="stat-item">检测点数: <span id="pointCount">0</span></div>
                    <div class="stat-item">帧率: <span id="fps">0</span></div>
                </div>
            </div>
            
            <div class="point-cloud-section">
                <h2 class="section-title">3D点云视图</h2>
                <canvas id="pointCloud"></canvas>
                <div class="controls">
                    <button id="resetView">重置视图</button>
                    <button id="toggleRotation">暂停旋转</button>
                </div>
                <div class="stats">
                    <div class="stat-item">3D点数: <span id="point3DCount">0</span></div>
                    <div class="stat-item">深度范围: <span id="depthRange">0 - 0</span></div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h2>使用说明</h2>
            <ul>
                <li>首次使用需允许浏览器访问摄像头权限，否则无法获取摄像头列表</li>
                <li>从下拉菜单选择要使用的摄像头，点击"开始检测"启动流程</li>
                <li>左侧摄像头视图中，红色点为实时检测的特征点（模拟角点检测）</li>
                <li>右侧3D视图基于特征点生成点云，颜色随空间位置变化，点大小随深度变化</li>
                <li>"重置视图"可恢复3D点云初始视角，"暂停旋转"可切换自动旋转状态</li>
                <li>切换摄像头前需先点击"停止检测"，避免流冲突</li>
                <li>本演示使用模拟深度数据（基于特征点位置计算），实际场景需结合深度相机</li>
            </ul>
        </div>
    </div>

    <script>
        // 1. 元素获取
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const pointCloudCanvas = document.getElementById('pointCloud');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const resetViewBtn = document.getElementById('resetView');
        const toggleRotationBtn = document.getElementById('toggleRotation');
        const pointCountEl = document.getElementById('pointCount');
        const fpsEl = document.getElementById('fps');
        const point3DEl = document.getElementById('point3DCount');
        const depthRangeEl = document.getElementById('depthRange');
        const cameraSelect = document.getElementById('cameraSelect');
        const cameraLoading = document.getElementById('cameraLoading');

        // 2. 全局变量
        let stream = null;          // 摄像头流
        let featurePoints = [];     // 2D特征点
        let pointCloud = [];        // 3D点云数据
        let lastTime = 0;           // 帧率计算时间戳
        let frameCount = 0;         // 帧计数器
        let currentFps = 0;         // 当前帧率
        let isRotating = true;      // 点云是否自动旋转
        let rotationAngle = 0;      // 旋转角度
        let gl = null;              // WebGL上下文
        let program = null;         // WebGL着色器程序
        let animationId = null;     // 动画帧ID（用于停止动画）
        let modelMatrix = null;     // 模型矩阵
        let viewMatrix = null;      // 视图矩阵
        let projMatrix = null;      // 投影矩阵
        let cameraList = [];        // 可用摄像头列表

        // 3. 页面加载完成后初始化
        window.addEventListener('load', init);

        // 4. 核心初始化函数
        function init() {
            // 初始化画布尺寸
            initCanvasSize();
            // 初始化WebGL（3D渲染核心）
            if (!initWebGL()) {
                alert('您的浏览器不支持WebGL，无法显示3D点云');
            }
            // 初始化矩阵（3D空间计算）
            initMatrices();
            // 加载摄像头列表
            loadCameras();
            // 绑定事件
            bindEvents();
            // 初始渲染（空点云）
            renderPointCloud();
        }

        // 5. 初始化画布尺寸
        function initCanvasSize() {
            // 点云画布尺寸（跟随容器）
            pointCloudCanvas.width = pointCloudCanvas.offsetWidth;
            pointCloudCanvas.height = pointCloudCanvas.offsetHeight;
        }

        // 6. WebGL初始化（3D渲染核心）
        function initWebGL() {
            try {
                // 获取WebGL上下文
                gl = pointCloudCanvas.getContext('webgl') || pointCloudCanvas.getContext('experimental-webgl');
                if (!gl) return false;

                // 设置渲染参数
                gl.viewport(0, 0, pointCloudCanvas.width, pointCloudCanvas.height);
                gl.clearColor(0.1, 0.1, 0.2, 1.0); // 深蓝色背景
                gl.enable(gl.DEPTH_TEST);          // 启用深度测试（避免遮挡错误）

                // 创建着色器程序
                program = createShaderProgram(
                    // 顶点着色器（处理3D坐标）
                    `attribute vec3 aPos;
                     uniform mat4 mvp;
                     varying vec3 vColor;
                     void main() {
                         gl_Position = mvp * vec4(aPos, 1.0);
                         // 基于位置生成颜色（直观区分空间位置）
                         vColor = (aPos + 1.0) / 2.0;
                         // 基于深度调整点大小（近大远小）
                         gl_PointSize = 6.0 - (aPos.z * 3.0);
                     }`,
                    // 片段着色器（处理像素颜色）
                    `precision mediump float;
                     varying vec3 vColor;
                     void main() {
                         // 圆形点（避免方形点生硬）
                         vec2 dist = gl_PointCoord - vec2(0.5);
                         if (dot(dist, dist) > 0.25) discard;
                         gl_FragColor = vec4(vColor, 1.0);
                     }`
                );

                return true;
            } catch (e) {
                console.error('WebGL初始化失败:', e);
                return false;
            }
        }

        // 7. 创建WebGL着色器程序
        function createShaderProgram(vertexSource, fragmentSource) {
            // 创建顶点着色器
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexSource);
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                console.error('顶点着色器编译失败:', gl.getShaderInfoLog(vertexShader));
                return null;
            }

            // 创建片段着色器
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentSource);
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                console.error('片段着色器编译失败:', gl.getShaderInfoLog(fragmentShader));
                return null;
            }

            // 链接程序
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('着色器程序链接失败:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        // 8. 初始化3D矩阵（空间变换核心）
        function initMatrices() {
            // 模型矩阵（物体自身变换）
            modelMatrix = createIdentityMatrix();
            // 视图矩阵（相机位置：在Z轴正方向，看向原点）
            viewMatrix = lookAtMatrix([0, 0, 5], [0, 0, 0], [0, 1, 0]);
            // 投影矩阵（透视投影，模拟人眼视角）
            projMatrix = perspectiveMatrix(45, pointCloudCanvas.width / pointCloudCanvas.height, 0.1, 100);
        }

        // 9. 加载可用摄像头列表
        async function loadCameras() {
            try {
                // 先请求权限（部分浏览器需权限才能获取摄像头列表）
                await requestCameraPermission();

                // 获取设备列表
                const devices = await navigator.mediaDevices.enumerateDevices();
                // 筛选视频输入设备（摄像头）
                cameraList = devices.filter(device => device.kind === 'videoinput');
                
                if (cameraList.length === 0) {
                    // 无可用摄像头
                    cameraSelect.innerHTML = '<option value="">无可用摄像头</option>';
                    cameraSelect.disabled = true;
                    startBtn.disabled = true;
                    cameraLoading.textContent = "未检测到可用摄像头";
                } else {
                    // 填充摄像头选择菜单
                    cameraSelect.innerHTML = '';
                    cameraList.forEach((camera, index) => {
                        const option = document.createElement('option');
                        option.value = camera.deviceId;
                        option.textContent = camera.label || `摄像头 ${index + 1}`;
                        cameraSelect.appendChild(option);
                    });
                    cameraSelect.disabled = false;
                    startBtn.disabled = false;
                    cameraLoading.textContent = "请点击开始检测启动摄像头";
                }
            } catch (err) {
                console.error('获取摄像头列表失败:', err);
                cameraSelect.innerHTML = '<option value="">获取摄像头失败</option>';
                cameraSelect.disabled = true;
                startBtn.disabled = true;
                cameraLoading.textContent = "获取摄像头失败，请检查权限";
            }
        }

        // 10. 请求摄像头权限
        async function requestCameraPermission() {
            try {
                // 尝试获取临时流触发权限请求
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                // 立即停止临时流
                tempStream.getTracks().forEach(track => track.stop());
            } catch (err) {
                console.warn('摄像头权限未授予:', err);
            }
        }

        // 11. 绑定事件处理函数
        function bindEvents() {
            startBtn.addEventListener('click', startDetection);
            stopBtn.addEventListener('click', stopDetection);
            resetViewBtn.addEventListener('click', resetView);
            toggleRotationBtn.addEventListener('click', toggleRotation);
            window.addEventListener('resize', handleResize);
        }

        // 12. 开始检测流程
        async function startDetection() {
            try {
                // 获取选中的摄像头ID
                const selectedCameraId = cameraSelect.value;
                if (!selectedCameraId) {
                    alert('请先选择一个摄像头');
                    return;
                }

                // 停止任何现有流
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                // 获取摄像头流
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        deviceId: selectedCameraId ? { exact: selectedCameraId } : undefined,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                // 显示视频和画布，隐藏加载提示
                video.srcObject = stream;
                video.style.display = 'block';
                canvas.style.display = 'block';
                cameraLoading.style.display = 'none';

                // 设置画布尺寸与视频一致
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                };

                // 更新按钮状态
                startBtn.disabled = true;
                stopBtn.disabled = false;
                cameraSelect.disabled = true;

                // 开始处理帧
                lastTime = performance.now();
                frameCount = 0;
                processFrame();
            } catch (err) {
                console.error('启动摄像头失败:', err);
                alert('无法启动摄像头: ' + err.message);
                resetUI();
            }
        }

        // 13. 停止检测流程
        function stopDetection() {
            // 停止视频流
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            // 停止动画帧
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            // 重置UI
            resetUI();
        }

        // 14. 重置UI状态
        function resetUI() {
            video.style.display = 'none';
            canvas.style.display = 'none';
            cameraLoading.style.display = 'flex';
            cameraLoading.textContent = "请点击开始检测启动摄像头";
            
            // 清空特征点
            featurePoints = [];
            pointCloud = [];
            updateStats();
            
            // 更新按钮状态
            startBtn.disabled = false;
            stopBtn.disabled = true;
            cameraSelect.disabled = false;
        }

        // 15. 处理每一帧（核心处理函数）
        function processFrame(timestamp) {
            // 继续请求下一帧
            animationId = requestAnimationFrame(processFrame);
            
            if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {
                return;
            }

            // 计算帧率
            calculateFps(timestamp);

            // 绘制视频帧到画布
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 镜像翻转画布以匹配视频显示
            ctx.scale(-1, 1);
            ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
            ctx.restore();

            // 检测特征点（模拟角点检测）
            detectFeaturePoints();
            
            // 绘制特征点
            drawFeaturePoints();
            
            // 生成3D点云
            generatePointCloud();
            
            // 渲染3D点云
            renderPointCloud();
            
            // 更新统计信息
            updateStats();
        }

        // 16. 计算帧率
        function calculateFps(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const elapsed = timestamp - lastTime;
            frameCount++;
            
            // 每秒钟更新一次帧率
            if (elapsed >= 1000) {
                currentFps = Math.round((frameCount * 1000) / elapsed);
                fpsEl.textContent = currentFps;
                lastTime = timestamp;
                frameCount = 0;
            }
        }

        // 17. 检测特征点（模拟）
        function detectFeaturePoints() {
            // 模拟角点检测：在图像中均匀分布一些点
            const pointsCount = 50 + Math.floor(Math.random() * 30); // 50-80个点
            featurePoints = [];
            
            for (let i = 0; i < pointsCount; i++) {
                // 避免边缘，留出10%的边距
                const margin = 0.1;
                const x = margin * canvas.width + Math.random() * canvas.width * (1 - 2 * margin);
                const y = margin * canvas.height + Math.random() * canvas.height * (1 - 2 * margin);
                
                // 为了让点看起来更像特征点，在某些区域增加密度
                const centerWeight = 0.3; // 中心区域权重
                if (x > canvas.width * 0.3 && x < canvas.width * 0.7 && 
                    y > canvas.height * 0.3 && y < canvas.height * 0.7) {
                    // 中心区域多生成一些点
                    if (Math.random() < centerWeight) {
                        featurePoints.push({ x, y });
                    }
                }
                
                featurePoints.push({ x, y });
            }
            
            // 去重和限制最大数量
            featurePoints = [...new Set(featurePoints.map(p => `${Math.round(p.x)},${Math.round(p.y)}`))]
                .map(coord => {
                    const [x, y] = coord.split(',').map(Number);
                    return { x, y };
                })
                .slice(0, 100); // 最多100个点
        }

        // 18. 绘制特征点
        function drawFeaturePoints() {
            ctx.save();
            ctx.fillStyle = 'red';
            
            featurePoints.forEach(point => {
                // 绘制红色圆点标记特征点
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }

        // 19. 生成3D点云（从2D特征点模拟3D坐标）
        function generatePointCloud() {
            pointCloud = [];
            
            if (featurePoints.length === 0) return;
            
            // 计算深度范围（模拟）
            const minDepth = 0.2;
            const maxDepth = 0.8;
            
            featurePoints.forEach(point => {
                // 将2D坐标归一化到[-1, 1]范围
                const normX = (point.x / canvas.width) * 2 - 1;
                const normY = -(point.y / canvas.height) * 2 + 1; // Y轴翻转
                
                // 基于位置模拟深度（中心区域更近，边缘区域更远）
                const distanceFromCenter = Math.sqrt(
                    Math.pow(normX, 2) + Math.pow(normY, 2)
                );
                // 映射到深度范围，中心区域深度值小（更近）
                const depth = minDepth + (maxDepth - minDepth) * Math.min(1, distanceFromCenter);
                
                // 添加一些随机扰动使点云更自然
                const jitter = 0.05;
                const x = normX + (Math.random() * 2 - 1) * jitter;
                const y = normY + (Math.random() * 2 - 1) * jitter;
                const z = depth + (Math.random() * 2 - 1) * jitter * 0.5;
                
                pointCloud.push(x, y, z);
            });
            
            // 更新深度范围显示
            depthRangeEl.textContent = `${minDepth.toFixed(2)} - ${maxDepth.toFixed(2)}`;
        }

        // 20. 渲染3D点云
        function renderPointCloud() {
            if (!gl || !program) return;
            
            // 清除画布
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // 使用着色器程序
            gl.useProgram(program);
            
            // 如果没有点云数据，直接返回
            if (pointCloud.length === 0) return;
            
            // 更新旋转（如果启用）
            if (isRotating) {
                rotationAngle += 0.01;
                modelMatrix = rotateYMatrix(rotationAngle);
            }
            
            // 计算MVP矩阵（模型*视图*投影）
            const mvpMatrix = multiplyMatrices(projMatrix, multiplyMatrices(viewMatrix, modelMatrix));
            
            // 创建点数据缓冲区
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pointCloud), gl.STREAM_DRAW);
            
            // 获取属性和 uniform 位置
            const aPosLoc = gl.getAttribLocation(program, 'aPos');
            const mvpLoc = gl.getUniformLocation(program, 'mvp');
            
            // 设置属性
            gl.enableVertexAttribArray(aPosLoc);
            gl.vertexAttribPointer(aPosLoc, 3, gl.FLOAT, false, 0, 0);
            
            // 设置 uniform
            gl.uniformMatrix4fv(mvpLoc, false, mvpMatrix);
            
            // 绘制点
            gl.drawArrays(gl.POINTS, 0, pointCloud.length / 3);
        }

        // 21. 重置3D视图
        function resetView() {
            rotationAngle = 0;
            modelMatrix = createIdentityMatrix();
            viewMatrix = lookAtMatrix([0, 0, 5], [0, 0, 0], [0, 1, 0]);
            renderPointCloud();
        }

        // 22. 切换自动旋转状态
        function toggleRotation() {
            isRotating = !isRotating;
            toggleRotationBtn.textContent = isRotating ? "暂停旋转" : "开始旋转";
        }

        // 23. 处理窗口大小变化
        function handleResize() {
            // 更新画布尺寸
            pointCloudCanvas.width = pointCloudCanvas.offsetWidth;
            pointCloudCanvas.height = pointCloudCanvas.offsetHeight;
            
            // 更新摄像头画布尺寸
            if (video.readyState > 0) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }
            
            // 更新WebGL视图
            if (gl) {
                gl.viewport(0, 0, pointCloudCanvas.width, pointCloudCanvas.height);
                // 更新投影矩阵
                projMatrix = perspectiveMatrix(45, pointCloudCanvas.width / pointCloudCanvas.height, 0.1, 100);
            }
        }

        // 24. 更新统计信息
        function updateStats() {
            pointCountEl.textContent = featurePoints.length;
            point3DEl.textContent = pointCloud.length / 3;
        }

        // 25. 矩阵运算工具函数（3D变换核心）
        
        // 创建单位矩阵
        function createIdentityMatrix() {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
        }

        // 矩阵乘法
        function multiplyMatrices(a, b) {
            const result = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        // 透视投影矩阵
        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov * Math.PI / 360);
            const nf = 1 / (near - far);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ];
        }

        // 视图矩阵（相机位置）
        function lookAtMatrix(eye, center, up) {
            const fx = center[0] - eye[0];
            const fy = center[1] - eye[1];
            const fz = center[2] - eye[2];
            
            // 计算前向量
            const fLen = Math.sqrt(fx * fx + fy * fy + fz * fz);
            const fxNorm = fx / fLen;
            const fyNorm = fy / fLen;
            const fzNorm = fz / fLen;
            
            // 计算右向量
            const sx = fyNorm * up[2] - fzNorm * up[1];
            const sy = fzNorm * up[0] - fxNorm * up[2];
            const sz = fxNorm * up[1] - fyNorm * up[0];
            const sLen = Math.sqrt(sx * sx + sy * sy + sz * sz);
            const sxNorm = sx / sLen;
            const syNorm = sy / sLen;
            const szNorm = sz / sLen;
            
            // 计算上向量
            const ux = syNorm * fzNorm - szNorm * fyNorm;
            const uy = szNorm * fxNorm - sxNorm * fzNorm;
            const uz = sxNorm * fyNorm - syNorm * fxNorm;
            
            // 计算平移
            const tx = -sxNorm * eye[0] - syNorm * eye[1] - szNorm * eye[2];
            const ty = -ux * eye[0] - uy * eye[1] - uz * eye[2];
            const tz = fxNorm * eye[0] + fyNorm * eye[1] + fzNorm * eye[2];
            
            return [
                sxNorm, ux, -fxNorm, 0,
                syNorm, uy, -fyNorm, 0,
                szNorm, uz, -fzNorm, 0,
                tx, ty, tz, 1
            ];
        }

        // Y轴旋转矩阵
        function rotateYMatrix(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            
            return [
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ];
        }
    </script>
</body>
</html>
