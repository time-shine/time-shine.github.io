<!DOCTYPE html>
<html>
<head>
    <title>Stereo ORB Feature Matching</title>
    <!-- 引入OpenCV.js -->
    <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
            margin: 10px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        canvas {
            border: 1px solid #ddd;
            margin: 5px;
            background-color: #000;
        }

        .button-container {
            margin: 15px 0;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 0 10px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

            button:hover {
                background-color: #45a049;
            }

            button:disabled {
                background-color: #cccccc;
                cursor: not-allowed;
            }

        .instructions {
            background-color: #fffde7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #ffd600;
        }
    </style>
</head>
<body>
    <h1>Stereo Camera Feature Matching</h1>

    <div class="instructions">
        <p><strong>使用说明：</strong> 此应用将摄像头输入分割为左右两个图像，检测ORB特征点并进行匹配。</p>
        <p>请确保您使用的是立体摄像头或并排拍摄的图像。</p>
    </div>

    <div class="button-container">
        <button id="startBtn">Start Camera</button>
        <button id="stopBtn" disabled>Stop Camera</button>
    </div>

    <div class="container">
        <div class="canvas-container">
            <h3>Original Stereo Image</h3>
            <canvas id="originalCanvas"></canvas>
        </div>
        <div class="canvas-container">
            <h3>Feature Matching Results</h3>
            <canvas id="matchCanvas"></canvas>
        </div>
    </div>

    <script type="text/javascript">
        let cv;
        let video;
        let originalCanvas = document.getElementById('originalCanvas');
        let matchCanvas = document.getElementById('matchCanvas');
        let ctx = originalCanvas.getContext('2d');
        let matchCtx = matchCanvas.getContext('2d');
        let stream = null;
        let processingInterval = null;

        // 等待OpenCV.js加载完成
        function onOpenCvReady() {
            cv = window.cv;
            console.log('OpenCV.js loaded successfully');

            // 绑定按钮事件
            document.getElementById('startBtn').addEventListener('click', startCamera);
            document.getElementById('stopBtn').addEventListener('click', stopCamera);
        }

        // 启动摄像头
        function startCamera() {
            // 创建视频元素
            video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;

            // 获取摄像头流
            navigator.mediaDevices.getUserMedia({
                video: { width: 1280, height: 480 }, // 适合立体图像的尺寸
                audio: false
            })
                .then(function (mediaStream) {
                    stream = mediaStream;
                    video.srcObject = stream;

                    // 视频准备就绪后开始处理
                    video.onloadedmetadata = function () {
                        // 设置画布尺寸
                        originalCanvas.width = video.videoWidth;
                        originalCanvas.height = video.videoHeight;
                        matchCanvas.width = video.videoWidth;
                        matchCanvas.height = video.videoHeight * 2; // 双倍高度用于显示匹配结果

                        // 开始处理视频帧
                        startProcessing();

                        // 更新按钮状态
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                    };
                })
                .catch(function (err) {
                    console.error("无法访问摄像头: " + err);
                    alert("无法访问摄像头，请确保您已授予摄像头权限。错误: " + err.message);
                });
        }

        // 停止摄像头
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            // 停止处理
            if (processingInterval) {
                clearInterval(processingInterval);
                processingInterval = null;
            }

            // 清空画布
            ctx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            matchCtx.clearRect(0, 0, matchCanvas.width, matchCanvas.height);

            // 更新按钮状态
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // 开始处理视频帧
        function startProcessing() {
            // 定期处理视频帧 (约30fps)
            processingInterval = setInterval(processFrame, 33);
        }

        // 处理单个视频帧
        function processFrame() {
            if (!video || !stream) return;

            try {
                // 绘制原始视频帧
                ctx.drawImage(video, 0, 0, originalCanvas.width, originalCanvas.height);

                // 将图像分割为左右两部分
                const width = originalCanvas.width / 2;
                const height = originalCanvas.height;

                // 获取左右图像数据
                const leftImageData = ctx.getImageData(0, 0, width, height);
                const rightImageData = ctx.getImageData(width, 0, width, height);

                // 创建OpenCV矩阵
                let leftMat = new cv.Mat(height, width, cv.CV_8UC4);
                let rightMat = new cv.Mat(height, width, cv.CV_8UC4);

                // 设置图像数据
                leftMat.data.set(new Uint8Array(leftImageData.data));
                rightMat.data.set(new Uint8Array(rightImageData.data));

                // 转换为灰度图
                let leftGray = new cv.Mat();
                let rightGray = new cv.Mat();
                cv.cvtColor(leftMat, leftGray, cv.COLOR_RGBA2GRAY);
                cv.cvtColor(rightMat, rightGray, cv.COLOR_RGBA2GRAY);

                // 检测特征点和计算描述符
                let orb = new cv.ORB();
                let leftKeyPoints = new cv.KeyPointVector();
                let rightKeyPoints = new cv.KeyPointVector();
                let leftDescriptors = new cv.Mat();
                let rightDescriptors = new cv.Mat();

                orb.detectAndCompute(leftGray, new cv.Mat(), leftKeyPoints, leftDescriptors);
                orb.detectAndCompute(rightGray, new cv.Mat(), rightKeyPoints, rightDescriptors);

                // 特征匹配
                let matches = new cv.DMatchVector();
                let bf = new cv.BFMatcher(cv.NORM_HAMMING, true);
                bf.match(leftDescriptors, rightDescriptors, matches);

                // 绘制匹配结果
                drawMatches(leftMat, rightMat, leftKeyPoints, rightKeyPoints, matches);

                // 清理内存
                leftMat.delete();
                rightMat.delete();
                leftGray.delete();
                rightGray.delete();
                leftKeyPoints.delete();
                rightKeyPoints.delete();
                leftDescriptors.delete();
                rightDescriptors.delete();
                matches.delete();
                orb.delete();
                bf.delete();

            } catch (err) {
                console.error("处理帧时出错: " + err);
            }
        }

        // 绘制匹配结果
        function drawMatches(leftMat, rightMat, leftKeyPoints, rightKeyPoints, matches) {
            // 清空匹配画布
            matchCtx.clearRect(0, 0, matchCanvas.width, matchCanvas.height);

            const width = leftMat.cols;
            const height = leftMat.rows;

            // 在上半部分绘制原始图像（左右并排）
            // 绘制左图像
            let leftImageData = new ImageData(
                new Uint8ClampedArray(leftMat.data),
                width,
                height
            );
            matchCtx.putImageData(leftImageData, 0, 0);

            // 绘制右图像
            let rightImageData = new ImageData(
                new Uint8ClampedArray(rightMat.data),
                width,
                height
            );
            matchCtx.putImageData(rightImageData, width, 0);

            // 在下半部分绘制匹配结果
            const offsetY = height;

            // 绘制左图像的特征点
            matchCtx.putImageData(leftImageData, 0, offsetY);
            drawKeypoints(matchCtx, leftKeyPoints, 0, offsetY, '#ff0000');

            // 绘制右图像的特征点
            matchCtx.putImageData(rightImageData, width, offsetY);
            drawKeypoints(matchCtx, rightKeyPoints, width, offsetY, '#00ff00');

            // 绘制匹配线
            matchCtx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            matchCtx.lineWidth = 1;

            for (let i = 0; i < matches.size(); i++) {
                let match = matches.get(i);
                if (match.distance > 50) continue; // 过滤掉低质量的匹配

                let leftKp = leftKeyPoints.get(match.queryIdx);
                let rightKp = rightKeyPoints.get(match.trainIdx);

                matchCtx.beginPath();
                matchCtx.moveTo(leftKp.pt.x, offsetY + leftKp.pt.y);
                matchCtx.lineTo(width + rightKp.pt.x, offsetY + rightKp.pt.y);
                matchCtx.stroke();
            }
        }

        // 绘制特征点
        function drawKeypoints(ctx, keypoints, offsetX, offsetY, color) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;

            for (let i = 0; i < keypoints.size(); i++) {
                let kp = keypoints.get(i);
                let x = offsetX + kp.pt.x;
                let y = offsetY + kp.pt.y;
                let size = kp.size;

                // 绘制特征点
                ctx.beginPath();
                ctx.arc(x, y, size / 8, 0, 2 * Math.PI);
                ctx.fill();

                // 绘制方向
                let angle = kp.angle * Math.PI / 180;
                let endX = x + Math.cos(angle) * size;
                let endY = y + Math.sin(angle) * size;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }
    </script>
</body>
</html>