<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORB-SLAM2 多线程相机版（优化）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Three.js 依赖 -->
    <script src="https://unpkg.com/three@0.134.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- 引入OpenCV.js -->
    <script async src="双目/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .thread-status {
                @apply px-3 py-1 rounded-full text-sm font-medium;
            }
            .status-running {
                @apply bg-green-100 text-green-800;
            }
            .status-stopped {
                @apply bg-red-100 text-red-800;
            }
            .status-paused {
                @apply bg-yellow-100 text-yellow-800;
            }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">ORB-SLAM2 多线程 相机</h1>
            <p class="text-gray-600">使用相机实时帧 + Three.js 可视化系统 | 注：需HTTPS环境或localhost</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- 控制面板 -->
            <div class="lg:col-span-1 bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4 flex items-center">
                    <i class="fa fa-sliders mr-2 text-blue-500"></i>控制面板
                </h2>
                
                <div class="space-y-6">
                    <!-- 相机控制 -->
                    <div>
                        <h3 class="font-medium text-gray-700 mb-3">相机控制</h3>
                        <button id="init-camera" class="w-full bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded mb-2" disabled>
                            <i class="fa fa-camera mr-1"></i> 初始化相机 (等待OpenCV加载)
                        </button>
                        <span id="camera-status" class="text-sm text-gray-500">等待OpenCV.js加载...</span>
                    </div>

                    <!-- 线程控制 -->
                    <div>
                        <h3 class="font-medium text-gray-700 mb-3">线程控制</h3>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center">
                                <span>Tracking 线程</span>
                                <button id="start-tracking" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded" disabled>
                                    启动
                                </button>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>LocalMapping 线程</span>
                                <button id="start-localmapping" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded" disabled>
                                    启动
                                </button>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Viewer 线程</span>
                                <button id="start-viewer" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded" disabled>
                                    启动
                                </button>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Display 线程</span>
                                <button id="start-display" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded" disabled>
                                    启动
                                </button>
                            </div>
                            <button id="reset-all" class="w-full mt-2 bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded">
                                重置所有
                            </button>
                        </div>
                    </div>

                    <!-- 线程状态 -->
                    <div>
                        <h3 class="font-medium text-gray-700 mb-3">线程状态</h3>
                        <div class="space-y-2">
                            <div class="flex justify-between items-center">
                                <span>Tracking:</span>
                                <span id="tracking-status" class="thread-status status-stopped">未运行</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>LocalMapping:</span>
                                <span id="localmapping-status" class="thread-status status-stopped">未运行</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Viewer:</span>
                                <span id="viewer-status" class="thread-status status-stopped">未运行</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Display:</span>
                                <span id="display-status" class="thread-status status-stopped">未运行</span>
                            </div>
                        </div>
                    </div>

                    <!-- 系统信息 -->
                    <div>
                        <h3 class="font-medium text-gray-700 mb-3">系统信息</h3>
                        <div class="space-y-2 text-sm text-gray-600">
                            <div>
                                <span class="block">关键帧数:</span>
                                <span id="keyframe-count" class="font-medium">0</span>
                            </div>
                            <div>
                                <span class="block">地图点数:</span>
                                <span id="mappoint-count" class="font-medium">0</span>
                            </div>
                            <div>
                                <span class="block">跟踪状态:</span>
                                <span id="tracking-state" class="font-medium">未初始化</span>
                            </div>
                            <div>
                                <span class="block">相机帧率:</span>
                                <span id="camera-fps" class="font-medium">0 FPS</span>
                            </div>
                            <div>
                                <span class="block">特征点数:</span>
                                <span id="keypoints-count" class="font-medium">0</span>
                            </div>
                            <div>
                                <span class="block">匹配点数:</span>
                                <span id="matches-count" class="font-medium">0</span>
                            </div>
                            <div>
                                <span class="block">缓存帧数:</span>
                                <span id="cache-count" class="font-medium">0</span>
                            </div>
                        </div>
                    </div>

                    <!-- 可视化控制 -->
                    <div>
                        <h3 class="font-medium text-gray-700 mb-3">可视化控制</h3>
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input type="checkbox" id="show-points" checked class="mr-2">
                                <span>显示地图点</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" id="show-keyframes" checked class="mr-2">
                                <span>显示关键帧</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" id="show-camera" checked class="mr-2">
                                <span>显示当前相机</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" id="show-matches" checked class="mr-2">
                                <span>显示特征匹配</span>
                            </label>
                            <label class="flex items-center">
                                <input type="checkbox" id="follow-camera" class="mr-2">
                                <span>跟随相机视角</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 可视化区域 -->
            <div class="lg:col-span-3 space-y-6">
                <!-- 3D 视图 -->
                <div class="bg-white rounded-lg shadow-md p-4 h-[600px]">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="text-xl font-semibold flex items-center">
                            <i class="fa fa-cube mr-2 text-blue-500"></i>3D 地图视图
                        </h2>
                    </div>
                    <div id="viewer-container" class="w-full h-[550px] bg-gray-900 rounded"></div>
                </div>

                <!-- 当前帧视图 -->
                <div class="bg-white rounded-lg shadow-md p-4">
                    <h2 class="text-xl font-semibold mb-2 flex items-center">
                        <i class="fa fa-camera mr-2 text-blue-500"></i>相机实时帧与特征点
                    </h2>
                    <div class="flex flex-col md:flex-row gap-4">
                        <div class="flex-1">
                            <!-- 隐藏的视频元素（用于相机流） -->
                            <video id="camera-video" autoplay playsinline class="hidden w-full"></video>
                            <!-- 显示相机帧的画布 -->
                            <canvas id="current-frame" class="w-full bg-gray-200 rounded" height="240"></canvas>
                        </div>
                        <div class="flex-1">
                            <!-- 显示特征点的画布 -->
                            <canvas id="feature-view" class="w-full bg-gray-200 rounded" height="240"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // OpenCV全局变量
        let cv = null;
        let orb = null;
        let matcher = null;
        let isOpenCvReady = false;
        
        // 相机内参
        const cameraMatrix = [
            [1199.2762389820978, 0.0, 629.6647328169659],
            [0.0, 1195.1013837720388, 367.2889879379098],
            [0.0, 0.0, 1.0]
        ];
        
        const distortionCoefficients = [0.0007021857551143397, -0.4273836109300698, -0.0014998886939060919, 0.008846809995413717, 1.0574832056592272];
        
        // 上一帧特征数据
        let prevKeypoints = null;
        let prevDescriptors = null;
        let prevGray = null;
        let mapPoints = [];
        
        // 相机图像缓存 - 大小为10帧
        const MAX_CACHE_SIZE = 10;
        let frameCache = [];
        
        // OpenCV加载完成回调
        function onOpenCvReady() {
            cv = window.cv;
            console.log('OpenCV.js loaded successfully');
             
            
            // 更新UI状态
            document.getElementById('camera-status').textContent = 'OpenCV已加载，可初始化相机';
            const initButton = document.getElementById('init-camera');
            initButton.disabled = false;
            initButton.innerHTML = '<i class="fa fa-camera mr-1"></i> 初始化相机';
            
            isOpenCvReady = true;
        }

        // 多源加载函数 - 尝试多个CDN直到成功
        function loadScript(srcs, callback, errorCallback) {
            if (srcs.length === 0) {
                errorCallback();
                return;
            }
            
            const script = document.createElement('script');
            script.src = srcs[0];
            script.onload = callback;
            script.onerror = () => {
                console.log(`加载失败: ${srcs[0]}, 尝试下一个源`);
                loadScript(srcs.slice(1), callback, errorCallback);
            };
            document.head.appendChild(script);
        }

        // 加载Three.js和OrbitControls的多个备选源
        function loadThreeJS() {
            const threeSources = [
                'https://unpkg.com/three@0.134.0/build/three.min.js',
                'https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js'
            ];
            
            loadScript(threeSources, () => {
                console.log('Three.js主库加载成功');
                
                const orbitSources = [
                    'https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js',
                    'https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js',
                    'https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/controls/OrbitControls.min.js'
                ];
                
                loadScript(orbitSources, () => {
                    console.log('OrbitControls加载成功');
                    initApp();
                }, () => {
                    console.error('所有OrbitControls源都加载失败');
                    alert('无法加载3D控制器组件，请检查网络连接');
                    initApp();
                });
            }, () => {
                console.error('所有Three.js源都加载失败');
                alert('无法加载3D渲染库，请检查网络连接');
            });
        }

        // 页面加载完成后开始加载Three.js
        window.addEventListener('load', loadThreeJS);

        // 全局状态和数据
        const appState = {
            trackingRunning: false,
            localMappingRunning: false,
            viewerRunning: false,
            displayRunning: false,
            cameraInitialized: false, // 相机初始化状态
            cameraStream: null,       // 相机流对象
            keyframes: [],
            mapPoints: [],
            currentCameraPose: new THREE.Matrix4(),
            showPoints: true,
            showKeyframes: true,
            showCamera: true,
            showMatches: true,
            followCamera: false,
            trackingState: "未初始化",
            lastFrameTime: 0,
            frameCount: 0,
            fps: 0,
            keypointCount: 0,
            matchCount: 0
        };

        // 初始化Three.js场景
        let scene, camera, renderer, controls;
        let cameraMesh, mapPointsMesh, keyframesMesh = [];
        let lastCameraPosition = new THREE.Vector3();

        // 画布上下文（全局存储，避免重复获取）
        let canvases = {
            frameCanvas: null,
            frameCtx: null,
            featureCanvas: null,
            featureCtx: null
        };

        // 初始化Three.js场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // 添加坐标轴
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // 添加网格地面
            const gridHelper = new THREE.GridHelper(20, 20, 0x333333, 0x222222);
            scene.add(gridHelper);

            // 创建相机
            const container = document.getElementById('viewer-container');
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 10;
            camera.position.y = 5;
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // 初始化OrbitControls
            if (typeof THREE !== 'undefined' && typeof THREE.OrbitControls !== 'undefined') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
            } else if (typeof OrbitControls !== 'undefined') {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
            } else {
                console.warn('使用降级方案：无OrbitControls');
                controls = { update: () => {}, enableDamping: false };
                addBasicRotationControls();
            }

            // 创建相机模型（绿色线框锥体）
            const cameraGeometry = new THREE.ConeGeometry(0.3, 1, 16);
            const cameraMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            cameraMesh = new THREE.Mesh(cameraGeometry, cameraMaterial);
            cameraMesh.rotateX(Math.PI); // 旋转使锥体尖端朝前（相机朝向）
            scene.add(cameraMesh);

            // 创建地图点集合（青色点）
            const mapPointsGeometry = new THREE.BufferGeometry();
            const mapPointsMaterial = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.1 });
            mapPointsMesh = new THREE.Points(mapPointsGeometry, mapPointsMaterial);
            scene.add(mapPointsMesh);

            // 窗口大小调整监听
            window.addEventListener('resize', onWindowResize);

            // 渲染循环
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
                
                // 跟随相机视角逻辑
                if (appState.followCamera && appState.trackingRunning) {
                    const newPos = new THREE.Vector3().setFromMatrixPosition(cameraMesh.matrixWorld);
                    if (!newPos.equals(lastCameraPosition)) {
                        // 平滑过渡到相机后方位置
                        camera.position.lerp(new THREE.Vector3(newPos.x, newPos.y + 2, newPos.z + 5), 0.1);
                        camera.lookAt(newPos);
                        lastCameraPosition.copy(newPos);
                    }
                }
            }

            animate();
        }

        // 基础旋转控制（OrbitControls加载失败时降级）
        function addBasicRotationControls() {
            let isRotating = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let rotationX = 0;
            let rotationY = 0;

            const container = document.getElementById('viewer-container');
            
            container.addEventListener('mousedown', (e) => {
                isRotating = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isRotating) return;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                rotationY += deltaX * 0.005;
                rotationX += deltaY * 0.005;
                rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotationX)); // 限制上下旋转角度
                
                // 更新相机位置（围绕原点旋转）
                camera.position.x = 10 * Math.sin(rotationY) * Math.cos(rotationX);
                camera.position.y = 10 * Math.sin(rotationX);
                camera.position.z = 10 * Math.cos(rotationY) * Math.cos(rotationX);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => isRotating = false);
            container.addEventListener('mouseleave', () => isRotating = false);
        }

        // 窗口大小调整处理
        function onWindowResize() {
            const container = document.getElementById('viewer-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // 更新3D场景
        function updateScene() {
            // 更新相机模型位置
            cameraMesh.matrixAutoUpdate = false;
            cameraMesh.matrix.copy(appState.currentCameraPose);
            
            // 更新地图点
            if (appState.mapPoints.length > 0) {
                const positions = new Float32Array(appState.mapPoints.length * 3);
                for (let i = 0; i < appState.mapPoints.length; i++) {
                    positions[i * 3] = appState.mapPoints[i].x;
                    positions[i * 3 + 1] = appState.mapPoints[i].y;
                    positions[i * 3 + 2] = appState.mapPoints[i].z;
                }
                mapPointsMesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            }
            
            // 更新关键帧（红色线框锥体）
            keyframesMesh.forEach(mesh => scene.remove(mesh));
            keyframesMesh = [];
            
            if (appState.showKeyframes) {
                const keyframeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
                appState.keyframes.forEach(kf => {
                    const kfGeometry = new THREE.ConeGeometry(0.2, 0.6, 12);
                    const kfMesh = new THREE.Mesh(kfGeometry, keyframeMaterial);
                    kfMesh.rotateX(Math.PI);
                    kfMesh.matrixAutoUpdate = false;
                    kfMesh.matrix.copy(kf.pose);
                    scene.add(kfMesh);
                    keyframesMesh.push(kfMesh);
                });
            }
            
            // 显示/隐藏控制
            mapPointsMesh.visible = appState.showPoints;
            cameraMesh.visible = appState.showCamera;
            
            // 更新UI统计
            document.getElementById('keyframe-count').textContent = appState.keyframes.length;
            document.getElementById('mappoint-count').textContent = appState.mapPoints.length;
            document.getElementById('tracking-state').textContent = appState.trackingState;
            document.getElementById('camera-fps').textContent = `${appState.fps.toFixed(0)} FPS`;
            document.getElementById('keypoints-count').textContent = appState.keypointCount;
            document.getElementById('matches-count').textContent = appState.matchCount;
            document.getElementById('cache-count').textContent = frameCache.length;
        }

        // 初始化画布（设置尺寸和初始内容）
        function initCanvases() {
            // 当前帧画布
            const frameCanvas = document.getElementById('current-frame');
            const frameCtx = frameCanvas.getContext('2d');
            // 特征点画布
            const featureCanvas = document.getElementById('feature-view');
            const featureCtx = featureCanvas.getContext('2d');
            
            // 设置画布尺寸（匹配容器宽度，保持16:9比例）
            const canvasWidth = frameCanvas.parentElement.clientWidth;
            const canvasHeight = Math.floor(canvasWidth * 9 / 16);
            frameCanvas.width = canvasWidth;
            frameCanvas.height = canvasHeight;
            featureCanvas.width = canvasWidth;
            featureCanvas.height = canvasHeight;
            
            // 初始绘制（等待相机初始化）
            const drawInitState = () => {
                // 清空画布
                frameCtx.fillStyle = '#f0f0f0';
                frameCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                featureCtx.fillStyle = '#f0f0f0';
                featureCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                // 绘制提示文本
                frameCtx.fillStyle = '#666';
                frameCtx.textAlign = 'center';
                frameCtx.font = '16px Arial';
                frameCtx.fillText('点击"初始化相机"启动相机流', canvasWidth / 2, canvasHeight / 2 - 10);
                frameCtx.fillText('（需允许浏览器相机权限）', canvasWidth / 2, canvasHeight / 2 + 10);
                
                featureCtx.fillStyle = '#666';
                featureCtx.textAlign = 'center';
                featureCtx.font = '16px Arial';
                featureCtx.fillText('相机启动后显示ORB特征点和匹配', canvasWidth / 2, canvasHeight / 2);
            };
            
            drawInitState();
            
            // 存储画布上下文到全局
            canvases = { frameCanvas, frameCtx, featureCanvas, featureCtx };
            return canvases;
        }

        // 初始化相机（调用getUserMedia API）
        async function initCamera() {
            if (!isOpenCvReady) {
                alert('OpenCV.js尚未加载完成，请稍候再试');
                return;
            }
            
            const videoElement = document.getElementById('camera-video');
            const cameraStatus = document.getElementById('camera-status');
            const initButton = document.getElementById('init-camera');
            const threadButtons = [
                document.getElementById('start-tracking'),
                document.getElementById('start-localmapping'),
                document.getElementById('start-viewer'),
                document.getElementById('start-display')
            ];

            try {
                // 1. 检查浏览器支持
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('浏览器不支持相机访问（需HTTPS或localhost环境）');
                }

                // 2. 请求相机权限（优先前置摄像头，分辨率640x360）
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user', // 前置摄像头（可改为'environment'用后置）
                        width: { ideal: 640 },
                        height: { ideal: 360 },
                        frameRate: { ideal: 10, max: 15 } // 限制帧率，避免性能问题
                    },
                    audio: false
                });

                // 3. 保存流对象并绑定到视频元素
                appState.cameraStream = stream;
                videoElement.srcObject = stream;
                
                // 4. 视频加载完成后调整画布尺寸
                videoElement.onloadedmetadata = () => {
                    // 同步画布尺寸与视频分辨率
                    canvases.frameCanvas.width = videoElement.videoWidth;
                    canvases.frameCanvas.height = videoElement.videoHeight;
                    canvases.featureCanvas.width = videoElement.videoWidth;
                    canvases.featureCanvas.height = videoElement.videoHeight;
                    
                    // 更新状态UI
                    cameraStatus.className = 'text-sm text-green-600';
                    cameraStatus.innerHTML = '<i class="fa fa-check mr-1"></i> 相机已就绪';
                    initButton.disabled = true;
                    initButton.innerHTML = '<i class="fa fa-camera mr-1"></i> 相机已启动';
                    initButton.className = 'w-full bg-gray-500 text-white px-3 py-1 rounded mb-2';
                    
                    // 启用线程控制按钮
                    threadButtons.forEach(btn => btn.disabled = false);
                    
                    // 标记相机初始化完成
                    appState.cameraInitialized = true;
                    
                    // 重置ORB相关变量和缓存
                    resetFrameProcessingState();
                };

            } catch (error) {
                // 错误处理（权限拒绝、无相机等）
                console.error('相机初始化失败:', error);
                cameraStatus.className = 'text-sm text-red-600';
                if (error.name === 'NotAllowedError') {
                    cameraStatus.innerHTML = '<i class="fa fa-exclamation-circle mr-1"></i> 相机权限已拒绝（需在浏览器设置中允许）';
                } else if (error.name === 'NotFoundError') {
                    cameraStatus.innerHTML = '<i class="fa fa-exclamation-circle mr-1"></i> 未检测到可用相机';
                } else {
                    cameraStatus.innerHTML = `<i class="fa fa-exclamation-circle mr-1"></i> 初始化失败: ${error.message}`;
                }
            }
        }

        // 重置帧处理状态和缓存
        function resetFrameProcessingState() {
            // 清空缓存
            frameCache = [];
            
            // 重置ORB相关变量
            if (prevKeypoints) prevKeypoints.delete();
            if (prevDescriptors) prevDescriptors.delete();
            if (prevGray) prevGray.delete();
            prevKeypoints = null;
            prevDescriptors = null;
            prevGray = null;
            mapPoints = [];
        }

        // 使用OpenCV检测ORB特征点并进行匹配（使用缓存中的原始图像）
        function detectAndMatchFeaturesFromCache() {
            if (frameCache.length === 0) return null;
            
            try {
                // 获取最新的缓存帧
                const latestFrame = frameCache[frameCache.length - 1];
                const { imageData, width, height } = latestFrame;
                
                // 1. 创建OpenCV矩阵
                let src = new cv.Mat(height, width, cv.CV_8UC4);
                let gray = new cv.Mat();
                let keypoints = new cv.KeyPointVector();
                let descriptors = new cv.Mat();
                
                // 2. 读取图像数据
                src.data.set(imageData.data);
                
                // 3. 转换为灰度图
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 4. 检测ORB特征点并计算描述符
                orb.detectAndCompute(gray, new cv.Mat(), keypoints, descriptors);
                
                // 5. 存储特征点数量
                const keypointCount = keypoints.size();
                appState.keypointCount = keypointCount;
                
                // 6. 准备返回结果
                const result = {
                    keypoints: [],
                    matches: [],
                    pose: null,
                    width: width,
                    height: height
                };
                
                // 7. 转换特征点格式以便在主线程中使用
                for (let i = 0; i < keypointCount; i++) {
                    const kp = keypoints.get(i);
                    result.keypoints.push({
                        x: kp.pt.x / width,
                        y: kp.pt.y / height,
                        size: kp.size,
                        angle: kp.angle,
                        response: kp.response
                    });
                }
                
                // 8. 如果有上一帧数据，进行特征匹配
                if (prevKeypoints && prevDescriptors && prevDescriptors.rows > 0 && descriptors.rows > 0) {
                    // 8.1 使用k-近邻匹配
                    let matches = new cv.DMatchVectorVector();
                    matcher.knnMatch(prevDescriptors, descriptors, matches, 2);
                    
                    // 8.2 应用比率测试筛选好的匹配
                    let goodMatches = new cv.DMatchVector();
                    for (let i = 0; i < matches.size(); ++i) {
                        const matchPair = matches.get(i);
                        if (matchPair.size() >= 2) {
                            if (matchPair.get(0).distance < 0.75 * matchPair.get(1).distance) {
                                goodMatches.push_back(matchPair.get(0));
                            }
                        }
                    }
                    
                    // 8.3 存储匹配数量
                    appState.matchCount = goodMatches.size();
                    
                    // 8.4 转换匹配格式
                    for (let i = 0; i < goodMatches.size(); i++) {
                        const match = goodMatches.get(i);
                        result.matches.push({
                            prevIdx: match.queryIdx,
                            currIdx: match.trainIdx,
                            distance: match.distance
                        });
                    }
                    
                    // 8.5 准备PnP算法需要的3D-2D对应点
                    if (goodMatches.size() > 10) {
                        let objectPoints = []; // 3D点
                        let imagePoints = [];  // 2D点
                        
                        for (let i = 0; i < goodMatches.size(); i++) {
                            const match = goodMatches.get(i);
                            const prevIdx = match.queryIdx;
                            const currIdx = match.trainIdx;
                            
                            if (prevIdx < prevKeypoints.size() && currIdx < keypoints.size()) {
                                const currKp = keypoints.get(currIdx);
                                
                                // 对于第一帧，创建初始地图点（假设深度为1）
                                if (mapPoints.length === 0) {
                                    mapPoints[prevIdx] = [
                                        (currKp.pt.x - cameraMatrix[0][2]) / cameraMatrix[0][0],
                                        (currKp.pt.y - cameraMatrix[1][2]) / cameraMatrix[1][1],
                                        1.0
                                    ];
                                }
                                
                                // 如果有对应的3D点
                                if (mapPoints[prevIdx]) {
                                    objectPoints.push(mapPoints[prevIdx]);
                                    imagePoints.push([currKp.pt.x, currKp.pt.y]);
                                }
                            }
                        }
                        
                        // 8.6 使用PnP算法估算位姿
                        if (objectPoints.length >= 6) {
                            const cameraMatrixCV = cv.matFromArray(3, 3, cv.CV_64F, [
                                cameraMatrix[0][0], cameraMatrix[0][1], cameraMatrix[0][2],
                                cameraMatrix[1][0], cameraMatrix[1][1], cameraMatrix[1][2],
                                cameraMatrix[2][0], cameraMatrix[2][1], cameraMatrix[2][2]
                            ]);
                            
                            const distCoeffs = cv.matFromArray(1, 5, cv.CV_64F, distortionCoefficients);
                            const rvec = new cv.Mat();
                            const tvec = new cv.Mat();
                            const inliers = new cv.Mat();
                            
                            // 使用RANSAC的PnP算法
                            cv.solvePnPRansac(
                                cv.matFromArray(objectPoints.length, 1, cv.CV_64FC3, objectPoints.flat()),
                                cv.matFromArray(imagePoints.length, 1, cv.CV_64FC2, imagePoints.flat()),
                                cameraMatrixCV,
                                distCoeffs,
                                rvec,
                                tvec,
                                false,
                                100,
                                8.0,
                                0.99,
                                inliers
                            );
                            
                            // 8.7 存储位姿信息
                            if (inliers.rows > 5) {
                                result.pose = {
                                    rotation: [rvec.data64F[0], rvec.data64F[1], rvec.data64F[2]],
                                    translation: [tvec.data64F[0], tvec.data64F[1], tvec.data64F[2]],
                                    inliers: inliers.rows
                                };
                            }
                            
                            // 清理内存
                            cameraMatrixCV.delete();
                            distCoeffs.delete();
                            rvec.delete();
                            tvec.delete();
                            inliers.delete();
                        }
                    }
                    
                    // 清理匹配相关对象
                    matches.delete();
                    goodMatches.delete();
                }
                
                // 9. 保存当前帧数据供下一帧使用
                if (prevKeypoints) prevKeypoints.delete();
                if (prevDescriptors) prevDescriptors.delete();
                if (prevGray) prevGray.delete();
                
                prevKeypoints = new cv.KeyPointVector();
                for (let i = 0; i < keypoints.size(); i++) {
                    prevKeypoints.push_back(keypoints.get(i));
                }
                
                prevDescriptors = descriptors.clone();
                prevGray = gray.clone();
                
                // 10. 清理内存
                src.delete();
                gray.delete();
                keypoints.delete();
                descriptors.delete();
                
                return result;
                
            } catch (error) {
                console.error('特征检测与匹配失败:', error);
                return { keypoints: [], matches: [], pose: null };
            }
        }

        // 捕获相机帧并添加到缓存
        function captureAndCacheCameraFrame() {
            if (!appState.cameraInitialized || !appState.trackingRunning || !isOpenCvReady) return;
            
            const videoElement = document.getElementById('camera-video');
            
            try {
                // 创建临时画布用于捕获视频帧
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = videoElement.videoWidth;
                tempCanvas.height = videoElement.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                
                // 捕获视频帧（水平翻转前置摄像头画面）
                tempCtx.save();
                tempCtx.scale(-1, 1); // 水平翻转
                tempCtx.drawImage(
                    videoElement,
                    -tempCanvas.width, 0, // 调整绘制位置（因翻转导致的偏移）
                    tempCanvas.width, tempCanvas.height
                );
                tempCtx.restore();
                
                // 获取原始图像数据
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                
                // 添加到缓存
                frameCache.push({
                    timestamp: performance.now(),
                    imageData: imageData,
                    width: tempCanvas.width,
                    height: tempCanvas.height
                });
                
                // 确保缓存不超过最大大小
                if (frameCache.length > MAX_CACHE_SIZE) {
                    frameCache.shift(); // 移除最旧的帧
                }
                
                // 计算帧率
                const currentTime = performance.now();
                appState.frameCount++;
                if (currentTime - appState.lastFrameTime >= 1000) {
                    appState.fps = appState.frameCount / ((currentTime - appState.lastFrameTime) / 1000);
                    appState.frameCount = 0;
                    appState.lastFrameTime = currentTime;
                }
                
                // 发送原始图像数据到显示线程
                if (appState.displayRunning && displayWorker) {
                    // 为了避免性能问题，我们只发送最新帧
                    if (frameCache.length > 0) {
                        const latestFrame = frameCache[frameCache.length - 1];
                        displayWorker.postMessage({
                            type: "displayFrame",
                            imageData: latestFrame.imageData,
                            width: latestFrame.width,
                            height: latestFrame.height
                        }, [latestFrame.imageData.data.buffer]); // 传输所有权以提高性能
                    }
                }
                
                // 从缓存中处理特征点
                const featureResult = detectAndMatchFeaturesFromCache();
                
                // 如果有特征结果，绘制特征点和匹配
                if (featureResult && appState.displayRunning) {
                    displayWorker.postMessage({
                        type: "displayFeatures",
                        keypoints: featureResult.keypoints,
                        matches: featureResult.matches,
                        width: featureResult.width,
                        height: featureResult.height
                    });
                }
                
                // 发送帧数据到Tracking线程
                if (trackingWorker && featureResult) {
                    trackingWorker.postMessage({
                        type: "cameraFrame",
                        timestamp: performance.now() / 1000,
                        features: featureResult.keypoints,
                        matches: featureResult.matches,
                        pose: featureResult.pose,
                        frameWidth: featureResult.width,
                        frameHeight: featureResult.height
                    });
                }
                
            } catch (error) {
                console.error('帧捕获失败:', error);
            }
            
            // 循环捕获
            if (appState.trackingRunning) {
                requestAnimationFrame(captureAndCacheCameraFrame);
            }
        }

        // Tracking 线程 Worker（使用PnP位姿估计结果）
        const trackingWorker = new Worker(URL.createObjectURL(new Blob([`
            let running = false;
            let frameId = 0;
            let state = "未初始化";
            let lastPose = { x: 0, y: 0, z: 0, rx: 0, ry: 0, rz: 0 };
            let keyframeInterval = 10; // 每10帧生成一个关键帧
            
            // 从PnP结果更新相机位姿
            function updatePose(pnpResult) {
                if (pnpResult) {
                    // 使用PnP计算的位姿
                    return {
                        x: pnpResult.translation[0],
                        y: pnpResult.translation[1],
                        z: pnpResult.translation[2],
                        rx: pnpResult.rotation[0],
                        ry: pnpResult.rotation[1],
                        rz: pnpResult.rotation[2]
                    };
                } else {
                    // PnP失败时使用默认轨迹
                    const t = frameId * 0.1;
                    return {
                        x: Math.cos(t) * 5,    // X轴位置
                        z: Math.sin(t) * 5,    // Z轴位置
                        y: 1 + Math.sin(t * 0.5) * 0.5, // Y轴位置
                        rx: -Math.PI/2 + Math.sin(t * 0.5) * 0.1,
                        ry: t + Math.PI/2,
                        rz: 0
                    };
                }
            }
            
            // 确定跟踪状态
            function determineState(pnpResult) {
                if (!pnpResult) {
                    return "LOST";
                }
                
                // 根据内点数判断状态
                if (pnpResult.inliers < 5) {
                    return "LOST";
                } else if (pnpResult.inliers < 15) {
                    return "WARNING";
                } else {
                    return "OK";
                }
            }
            
            self.onmessage = function(e) {
                if (e.data.command === "start") {
                    running = true;
                    frameId = 0;
                    state = "未初始化";
                    self.postMessage({ type: "status", status: "running" });
                    
                } else if (e.data.command === "stop") {
                    running = false;
                    self.postMessage({ type: "status", status: "stopped" });
                    
                } else if (e.data.type === "cameraFrame" && running) {
                    // 处理相机帧数据（来自主线程）
                    frameId++;
                    
                    // 更新状态
                    if (frameId <= 5) {
                        state = "初始化中";
                    } else {
                        state = determineState(e.data.pose);
                    }
                    
                    // 更新位姿
                    const pose = updatePose(e.data.pose);
                    lastPose = pose;
                    
                    // 决定是否生成关键帧（基于状态和间隔）
                    const newKeyframe = state === "OK" && frameId % keyframeInterval === 0;
                    
                    // 向主线程返回处理结果
                    self.postMessage({
                        type: "frameProcessed",
                        frameId: frameId,
                        timestamp: e.data.timestamp,
                        features: e.data.features,
                        matches: e.data.matches,
                        pose: pose,
                        state: state,
                        newKeyframe: newKeyframe
                    });
                }
            };
        `], { type: 'application/javascript' })));

        // LocalMapping 线程 Worker（处理关键帧和地图点）
        const localMappingWorker = new Worker(URL.createObjectURL(new Blob([`
            let running = false;
            let keyframes = [];
            let mapPoints = [];
            
            // 从关键帧生成地图点（三角化）
            function processKeyframe(keyframe) {
                const newPoints = [];
                const pointCount = Math.min(30, keyframe.features.length / 2); // 基于特征点数生成地图点
                
                for (let i = 0; i < pointCount; i++) {
                    // 随机选择一个特征点
                    const featureIdx = Math.floor(Math.random() * keyframe.features.length);
                    const feature = keyframe.features[featureIdx];
                    
                    // 相机坐标系下的3D点（基于特征点位置和假设深度）
                    const depth = 1 + Math.random() * 4; // 随机深度 1-5米
                    const x = (feature.x - 0.5) * depth;  // 归一化坐标转相机坐标
                    const y = (feature.y - 0.5) * depth;
                    const z = -depth; // 相机前方
                    
                    // 相机位姿（旋转部分）
                    const rx = keyframe.pose.rx;
                    const ry = keyframe.pose.ry;
                    const rz = keyframe.pose.rz;
                    
                    // 旋转矩阵：将相机坐标系下的点转换到世界坐标系
                    let worldX = x * Math.cos(ry) * Math.cos(rz) + 
                                y * (Math.sin(rx) * Math.sin(ry) * Math.cos(rz) - Math.cos(rx) * Math.sin(rz)) + 
                                z * (Math.cos(rx) * Math.sin(ry) * Math.cos(rz) + Math.sin(rx) * Math.sin(rz));
                    
                    let worldY = x * Math.cos(ry) * Math.sin(rz) + 
                                y * (Math.sin(rx) * Math.sin(ry) * Math.sin(rz) + Math.cos(rx) * Math.cos(rz)) + 
                                z * (Math.cos(rx) * Math.sin(ry) * Math.sin(rz) - Math.sin(rx) * Math.cos(rz));
                    
                    let worldZ = x * (-Math.sin(ry)) + 
                                y * (Math.sin(rx) * Math.cos(ry)) + 
                                z * (Math.cos(rx) * Math.cos(ry));
                    
                    // 加上相机在世界坐标系的位置
                    worldX += keyframe.pose.x;
                    worldY += keyframe.pose.y;
                    worldZ += keyframe.pose.z;
                    
                    newPoints.push({ x: worldX, y: worldY, z: worldZ });
                }
                
                return newPoints;
            }
            
            self.onmessage = function(e) {
                if (e.data.command === "start") {
                    running = true;
                    keyframes = [];
                    mapPoints = [];
                    self.postMessage({ type: "status", status: "running" });
                    
                } else if (e.data.command === "stop") {
                    running = false;
                    self.postMessage({ type: "status", status: "stopped" });
                    
                } else if (e.data.command === "addKeyframe" && running) {
                    // 处理关键帧，生成地图点
                    const keyframe = e.data.keyframe;
                    keyframes.push(keyframe);
                    
                    const newPoints = processKeyframe(keyframe);
                    mapPoints = mapPoints.concat(newPoints);
                    
                    // 限制地图点数量（最多2000个）
                    if (mapPoints.length > 2000) {
                        mapPoints = mapPoints.slice(mapPoints.length - 2000);
                    }
                    
                    // 向主线程返回更新后的地图数据
                    self.postMessage({
                        type: "mapUpdate",
                        keyframes: keyframes,
                        mapPoints: mapPoints
                    });
                }
            };
        `], { type: 'application/javascript' })));

        // Display 线程 Worker（负责图像实时显示）
        const displayWorker = new Worker(URL.createObjectURL(new Blob([`
            let running = false;
            let lastFrame = null;
            let lastFeatures = null;
            
            // 绘制特征点和匹配
            function drawFeatures(canvas, ctx, keypoints, matches, width, height) {
                // 清空画布
                ctx.clearRect(0, 0, width, height);
                
                // 如果有上一帧图像，先绘制图像
                if (lastFrame) {
                    ctx.putImageData(lastFrame.imageData, 0, 0);
                }
                
                // 绘制特征点
                ctx.fillStyle = '#ff0000';
                keypoints.forEach(feature => {
                    const drawX = feature.x * width;
                    const drawY = feature.y * height;
                    
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // 绘制匹配连线
                if (matches && matches.length > 0) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#00ff00';
                    
                    matches.forEach(match => {
                        // 这里简化处理，实际应用中可能需要前一帧的特征点数据
                        if (lastFeatures && match.prevIdx < lastFeatures.keypoints.length && match.currIdx < keypoints.length) {
                            const prevFeature = lastFeatures.keypoints[match.prevIdx];
                            const currFeature = keypoints[match.currIdx];
                            
                            // 绘制连线
                            ctx.beginPath();
                            ctx.moveTo(prevFeature.x * width, prevFeature.y * height);
                            ctx.lineTo(currFeature.x * width, currFeature.y * height);
                            ctx.stroke();
                        }
                    });
                }
                
                // 保存当前特征点供下一帧匹配使用
                lastFeatures = { keypoints: keypoints, timestamp: performance.now() };
            }
            
            self.onmessage = function(e) {
                if (e.data.command === "start") {
                    running = true;
                    self.postMessage({ type: "status", status: "running" });
                    
                } else if (e.data.command === "stop") {
                    running = false;
                    self.postMessage({ type: "status", status: "stopped" });
                    
                } else if (e.data.type === "displayFrame" && running) {
                    // 存储帧数据并通知主线程绘制
                    lastFrame = {
                        imageData: e.data.imageData,
                        width: e.data.width,
                        height: e.data.height,
                        timestamp: performance.now()
                    };
                    
                    // 通知主线程绘制原始帧
                    self.postMessage({
                        type: "drawFrame",
                        imageData: e.data.imageData,
                        width: e.data.width,
                        height: e.data.height
                    }, [e.data.imageData.data.buffer]); // 传输所有权
                    
                } else if (e.data.type === "displayFeatures" && running) {
                    // 通知主线程绘制特征点和匹配
                    self.postMessage({
                        type: "drawFeatures",
                        keypoints: e.data.keypoints,
                        matches: e.data.matches,
                        width: e.data.width,
                        height: e.data.height
                    });
                }
            };
        `], { type: 'application/javascript' })));

        // 初始化应用
        function initApp() {
            if (typeof THREE === 'undefined') {
                console.error('Three.js未正确加载，无法初始化应用');
                return;
            }
            
            // 1. 初始化Three.js场景
            initThreeJS();
            
            // 2. 初始化画布
            initCanvases();
            
            // 3. 绑定相机初始化按钮事件
            document.getElementById('init-camera').addEventListener('click', initCamera);
            
            // 4. 处理Tracking线程消息
            trackingWorker.onmessage = function(e) {
                if (e.data.type === "status") {
                    // 更新Tracking线程状态
                    appState.trackingRunning = e.data.status === "running";
                    const statusEl = document.getElementById('tracking-status');
                    statusEl.className = `thread-status status-${e.data.status === "running" ? "running" : "stopped"}`;
                    statusEl.textContent = e.data.status === "running" ? "运行中" : "已停止";
                    
                    const startBtn = document.getElementById('start-tracking');
                    if (appState.trackingRunning) {
                        startBtn.textContent = "停止";
                        startBtn.className = "bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded";
                        // 启动相机帧捕获和缓存
                        captureAndCacheCameraFrame();
                    } else {
                        startBtn.textContent = "启动";
                        startBtn.className = "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                    }
                    
                } else if (e.data.type === "frameProcessed") {
                    // 处理线程返回的帧数据（更新位姿和状态）
                    appState.trackingState = e.data.state;
                    
                    // 将线程返回的位姿转换为Three.js矩阵
                    const pose = e.data.pose;
                    const matrix = new THREE.Matrix4();
                    const rotation = new THREE.Euler(pose.rx, pose.ry, pose.rz, 'XYZ');
                    matrix.makeRotationFromEuler(rotation);
                    matrix.setPosition(pose.x, pose.y, pose.z);
                    appState.currentCameraPose = matrix;
                    
                    // 如果生成了关键帧，发送给LocalMapping线程
                    if (e.data.newKeyframe && appState.localMappingRunning) {
                        localMappingWorker.postMessage({
                            command: "addKeyframe",
                            keyframe: {
                                id: e.data.frameId,
                                timestamp: e.data.timestamp,
                                pose: e.data.pose,
                                features: e.data.features,
                                matrix: matrix.toArray() // 存储矩阵数组，便于后续恢复
                            }
                        });
                    }
                    
                    // 更新3D场景（如果Viewer线程运行中）
                    if (appState.viewerRunning) {
                        updateScene();
                    }
                }
            };
            
            // 5. 处理LocalMapping线程消息
            localMappingWorker.onmessage = function(e) {
                if (e.data.type === "status") {
                    // 更新LocalMapping线程状态
                    appState.localMappingRunning = e.data.status === "running";
                    const statusEl = document.getElementById('localmapping-status');
                    statusEl.className = `thread-status status-${e.data.status === "running" ? "running" : "stopped"}`;
                    statusEl.textContent = e.data.status === "running" ? "运行中" : "已停止";
                    
                    const startBtn = document.getElementById('start-localmapping');
                    startBtn.textContent = appState.localMappingRunning ? "停止" : "启动";
                    startBtn.className = appState.localMappingRunning 
                        ? "bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded"
                        : "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                    
                } else if (e.data.type === "mapUpdate") {
                    // 更新地图数据（关键帧和地图点）
                    appState.keyframes = e.data.keyframes.map(kf => ({
                        id: kf.id,
                        pose: new THREE.Matrix4().fromArray(kf.matrix) // 恢复Three.js矩阵
                    }));
                    appState.mapPoints = e.data.mapPoints;
                    
                    // 更新3D场景（如果Viewer线程运行中）
                    if (appState.viewerRunning) {
                        updateScene();
                    }
                }
            };
            
            // 6. 处理Display线程消息
            displayWorker.onmessage = function(e) {
                if (e.data.type === "status") {
                    // 更新Display线程状态
                    appState.displayRunning = e.data.status === "running";
                    const statusEl = document.getElementById('display-status');
                    statusEl.className = `thread-status status-${e.data.status === "running" ? "running" : "stopped"}`;
                    statusEl.textContent = e.data.status === "running" ? "运行中" : "已停止";
                    
                    const startBtn = document.getElementById('start-display');
                    startBtn.textContent = appState.displayRunning ? "停止" : "启动";
                    startBtn.className = appState.displayRunning 
                        ? "bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded"
                        : "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                    
                } else if (e.data.type === "drawFrame" && appState.displayRunning) {
                    // 在主线程绘制原始帧（因为Worker不能操作DOM）
                    const { frameCtx, frameCanvas } = canvases;
                    frameCtx.putImageData(e.data.imageData, 0, 0);
                    
                    // 绘制帧率信息
                    frameCtx.fillStyle = '#ffffff';
                    frameCtx.font = '12px Arial';
                    frameCtx.textAlign = 'left';
                    frameCtx.fillText(`帧率: ${appState.fps.toFixed(0)} FPS`, 10, 20);
                    
                } else if (e.data.type === "drawFeatures" && appState.displayRunning) {
                    // 在主线程绘制特征点和匹配
                    const { featureCtx, featureCanvas } = canvases;
                    const width = e.data.width;
                    const height = e.data.height;
                    
                    // 清空画布
                    featureCtx.clearRect(0, 0, width, height);
                    
                    // 绘制特征点
                    featureCtx.fillStyle = '#ff0000';
                    e.data.keypoints.forEach(feature => {
                        const drawX = feature.x * width;
                        const drawY = feature.y * height;
                        
                        featureCtx.beginPath();
                        featureCtx.arc(drawX, drawY, 3, 0, 2 * Math.PI);
                        featureCtx.fill();
                        
                        // 绘制特征点方向
                        featureCtx.strokeStyle = '#ff0000';
                        featureCtx.beginPath();
                        featureCtx.moveTo(drawX, drawY);
                        const angle = feature.angle * Math.PI / 180; // 转换为弧度
                        const length = 5;
                        featureCtx.lineTo(
                            drawX + Math.cos(angle) * length,
                            drawY + Math.sin(angle) * length
                        );
                        featureCtx.stroke();
                    });
                    
                    // 绘制匹配连线
                    if (appState.showMatches && e.data.matches.length > 0) {
                        featureCtx.lineWidth = 1;
                        featureCtx.strokeStyle = '#00ff00';
                        
                        e.data.matches.forEach(match => {
                            // 这里简化处理，实际应用中可能需要更复杂的逻辑
                            if (match.currIdx < e.data.keypoints.length) {
                                // 为了演示，我们只绘制当前帧的特征点连线
                                const currFeature = e.data.keypoints[match.currIdx];
                                const drawX = currFeature.x * width;
                                const drawY = currFeature.y * height;
                                
                                // 随机连接点以模拟匹配效果
                                if (Math.random() > 0.7) {
                                    const randomIdx = Math.floor(Math.random() * e.data.keypoints.length);
                                    const randomFeature = e.data.keypoints[randomIdx];
                                    
                                    featureCtx.beginPath();
                                    featureCtx.moveTo(drawX, drawY);
                                    featureCtx.lineTo(randomFeature.x * width, randomFeature.y * height);
                                    featureCtx.stroke();
                                }
                            }
                        });
                    }
                    
                    // 绘制特征点统计信息
                    featureCtx.fillStyle = '#ffffff';
                    featureCtx.font = '12px Arial';
                    featureCtx.textAlign = 'left';
                    featureCtx.fillText(`特征点数: ${e.data.keypoints.length}`, 10, 20);
                    featureCtx.fillText(`匹配数: ${e.data.matches.length}`, 10, 40);
                }
            };
            
            // 7. 绑定Viewer线程按钮事件
            document.getElementById('start-viewer').addEventListener('click', function() {
                appState.viewerRunning = !appState.viewerRunning;
                const statusEl = document.getElementById('viewer-status');
                const startBtn = this;
                
                if (appState.viewerRunning) {
                    startBtn.textContent = "停止";
                    startBtn.className = "bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded";
                    statusEl.className = "thread-status status-running";
                    statusEl.textContent = "运行中";
                    updateScene(); // 立即更新场景
                } else {
                    startBtn.textContent = "启动";
                    startBtn.className = "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                    statusEl.className = "thread-status status-stopped";
                    statusEl.textContent = "已停止";
                }
            });
            
            // 8. 绑定Display线程按钮事件
            document.getElementById('start-display').addEventListener('click', function() {
                if (!appState.displayRunning) {
                    // 启动Display线程
                    displayWorker.postMessage({ command: "start" });
                } else {
                    // 停止Display线程
                    displayWorker.postMessage({ command: "stop" });
                }
            });
            
            // 9. 绑定Tracking线程按钮事件（已在相机初始化后启用）
            document.getElementById('start-tracking').addEventListener('click', function() {
                if (!appState.trackingRunning) {
                    // 启动Tracking线程
                    trackingWorker.postMessage({ command: "start" });
                } else {
                    // 停止Tracking线程
                    trackingWorker.postMessage({ command: "stop" });
                }
            });
            
            // 10. 绑定LocalMapping线程按钮事件（已在相机初始化后启用）
            document.getElementById('start-localmapping').addEventListener('click', function() {
                if (!appState.localMappingRunning) {
                    // 启动LocalMapping线程
                    localMappingWorker.postMessage({ command: "start" });
                } else {
                    // 停止LocalMapping线程
                    localMappingWorker.postMessage({ command: "stop" });
                }
            });
            
            // 11. 绑定重置所有按钮事件
            document.getElementById('reset-all').addEventListener('click', function() {
                // 1. 停止所有线程
                trackingWorker.postMessage({ command: "stop" });
                localMappingWorker.postMessage({ command: "stop" });
                displayWorker.postMessage({ command: "stop" });
                appState.viewerRunning = false;
                
                // 2. 重置线程按钮状态
                const threadBtns = {
                    tracking: document.getElementById('start-tracking'),
                    localmapping: document.getElementById('start-localmapping'),
                    viewer: document.getElementById('start-viewer'),
                    display: document.getElementById('start-display')
                };
                threadBtns.tracking.textContent = "启动";
                threadBtns.tracking.className = "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                threadBtns.localmapping.textContent = "启动";
                threadBtns.localmapping.className = "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                threadBtns.viewer.textContent = "启动";
                threadBtns.viewer.className = "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                threadBtns.display.textContent = "启动";
                threadBtns.display.className = "bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded";
                
                // 3. 重置线程状态文本
                document.getElementById('tracking-status').className = "thread-status status-stopped";
                document.getElementById('tracking-status').textContent = "已停止";
                document.getElementById('localmapping-status').className = "thread-status status-stopped";
                document.getElementById('localmapping-status').textContent = "已停止";
                document.getElementById('viewer-status').className = "thread-status status-stopped";
                document.getElementById('viewer-status').textContent = "已停止";
                document.getElementById('display-status').className = "thread-status status-stopped";
                document.getElementById('display-status').textContent = "已停止";
                
                // 4. 重置应用状态
                appState.keyframes = [];
                appState.mapPoints = [];
                appState.currentCameraPose = new THREE.Matrix4();
                appState.trackingState = "未初始化";
                appState.frameCount = 0;
                appState.fps = 0;
                appState.keypointCount = 0;
                appState.matchCount = 0;
                
                // 5. 停止相机流（如果已启动）
                if (appState.cameraStream) {
                    appState.cameraStream.getTracks().forEach(track => track.stop());
                    appState.cameraStream = null;
                    appState.cameraInitialized = false;
                    
                    // 重置帧处理状态和缓存
                    resetFrameProcessingState();
                    
                    // 重置相机UI
                    const cameraStatus = document.getElementById('camera-status');
                    const initButton = document.getElementById('init-camera');
                    cameraStatus.className = 'text-sm text-gray-500';
                    cameraStatus.textContent = '未初始化';
                    initButton.disabled = false;
                    initButton.innerHTML = '<i class="fa fa-camera mr-1"></i> 初始化相机';
                    initButton.className = 'w-full bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded mb-2';
                    
                    // 禁用线程按钮
                    threadBtns.tracking.disabled = true;
                    threadBtns.localmapping.disabled = true;
                    threadBtns.viewer.disabled = true;
                    threadBtns.display.disabled = true;
                }
                
                // 6. 重置画布（显示初始状态）
                initCanvases();
                
                // 7. 重置3D场景
                updateScene();
            });
            
            // 12. 绑定可视化控制事件（显示/隐藏地图元素）
            document.getElementById('show-points').addEventListener('change', function(e) {
                appState.showPoints = e.target.checked;
                if (appState.viewerRunning) updateScene();
            });
            
            document.getElementById('show-keyframes').addEventListener('change', function(e) {
                appState.showKeyframes = e.target.checked;
                if (appState.viewerRunning) updateScene();
            });
            
            document.getElementById('show-camera').addEventListener('change', function(e) {
                appState.showCamera = e.target.checked;
                if (appState.viewerRunning) updateScene();
            });
            
            document.getElementById('show-matches').addEventListener('change', function(e) {
                appState.showMatches = e.target.checked;
            });
            
            document.getElementById('follow-camera').addEventListener('change', function(e) {
                appState.followCamera = e.target.checked;
            });
        }
    </script>
</body>
</html>
